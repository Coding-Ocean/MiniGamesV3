#include"libOne.h"
int Rows = 3;
int Cols = 3;
int* Indices = 0;
int NumIndices = 0;
float TileW = 160;
float TileH = 90;
float OfstX = 200;
float OfstY = 200;
float SizeText=40;
void gmain()
{
	window(1920, 1080, full);
	
	NumIndices = Rows * Cols;
	Indices = new int[NumIndices];
	if (Indices == nullptr) {
		return;
	}
	for (int i = 0; i < NumIndices; i++) {
		Indices[i] = i;
	}
	int indexMouseHolding = -1;
	while (notQuit)
	{
		//マウスがあるタイルのインデックス
		int indexMouseOver = -1;
		//マウスがメニュー（全タイル）の範囲にある
		if (mouseX > OfstX && mouseX < OfstX + TileW * Cols &&
			mouseY > OfstY && mouseY < OfstY + TileH * Rows)
		{
			//マウスの位置から列番号と行番号に変換
			int mouseCol = (mouseX - OfstX) / TileW;
			int mouseRow = (mouseY - OfstY) / TileH;
			//１次元配列Indices[]のインデックスに変換
			indexMouseOver = Cols * mouseRow + mouseCol;
			//クリックされた時のインデックスを取っておく
			if (isTrigger(MOUSE_LBUTTON))
			{
				indexMouseHolding = indexMouseOver;
			}
			//マウスボタンを離した位置にとっておいたインデックスを挿入
			if (indexMouseHolding != -1 &&
				isRelease(MOUSE_LBUTTON)) 
			{
				//クリックされたタイルのインデックスを取っておく
				int workIndex = Indices[indexMouseHolding];
				//後ろのインデックスを前に持っていった時、後ろにずらす
				if (indexMouseOver < indexMouseHolding) 
				{
					for (int i = indexMouseHolding; i > indexMouseOver; i--) 
					{
						Indices[i] = Indices[i - 1];
					}
				}
				//前のインデックスを後ろに持っていった時、前にずらす
				else if (indexMouseOver > indexMouseHolding) 
				{
					for (int i = indexMouseHolding; i < indexMouseOver; i++) 
					{
						Indices[i] = Indices[i + 1];
					}
				}
				//上でずらすことにより挿入場所ができたので入れる
				Indices[indexMouseOver] = workIndex;
				//無効にする
				indexMouseHolding = -1;
			}
		}
		else {
			//無効にする
			indexMouseHolding = -1;
		}
		
		clear();
		for (int r = 0; r < Rows; r++) 
		{
			for (int c = 0; c < Cols; c++) 
			{
				
				float px = TileW * c + OfstX;
				float py = TileH * r + OfstY;
				fill(128);
				int i = Cols * r + c;
				if (i == indexMouseOver) {
					fill(255);
				}
				rect(px, py, TileW, TileH);

				textSize(SizeText);
				fill(0);
				textMode(BOTTOM);
				text(Indices[i], px, py+SizeText);
			}
		}
		if (indexMouseHolding >= 0) {
			fill(128);
			textMode(BCENTER);
			text(Indices[indexMouseHolding], mouseX, mouseY);
		}

	}


	delete[] Indices;
}